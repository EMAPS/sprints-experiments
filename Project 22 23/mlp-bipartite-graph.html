<!DOCTYPE html>
<html>
<head>
  <title>Multi-lateral funded projects dataset bipartite networks</title>
  <link href='http://fonts.googleapis.com/css?family=Alegreya+Sans:300,800' rel='stylesheet' type='text/css'>
  <style type="text/css">
    body {
      font-family: 'Alegreya Sans', sans-serif;
    }
    #container {
      max-width: 800px;
      margin: 20px;
    }
    body,
    #graph {
      margin: 0;
      padding: 0;
    }
    #graph {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    .font-loader {
      font-family: 'Alegreya Sans', sans-serif;
      position: absolute;
      height: 20px;
      top: -30px;
      color: white;
    }
  </style>
</head>
<body>
  <div class="font-loader">abc</div>
  <div id="graph"></div>
  <div id="container">
    <p>This bipartite network shows the relationship between the issues covered in the projects funded by the MLFs and the countries which received funds from the MLFs. Basically, it tries to answer: what kinds of issues did the MLF funded projects address? Are similar countries addressing similar challenges? What are the most popular types of projects funded? What are the gaps in the types of projects funded? The green circles represent the countries. The blue circles represent the types of projects proposed. The larger the circle, the more projects there are on this topic. The links are the projects.</p>

    <p>The words used to describe the projects were generated by either: using terms used in the title of the projects; using keywords used in the project summaries of the projects (available on websites of the various adaptation funds) or undertaking some desk based research to better understand the nature of the project to identify what the project is about and identify ourselves what we thought the keywords should be (for example, we would read a project description that showed that a particular project was about capacity building, building infrastructure and encouraging the diversification of livelihoods of farmers in mountainous regions. We would then use the keywords/categories used in the NAPA project database and say that the keywords for this project are: building capacity, infrastructure, livelihood diversification). To make sure we were able to compare the projects requested in the NAPAs and the projects funded through the MLFs we used the same categories/key words as those used in the NAPA project database. These were collected manually.</p>
  </div>

  <script type="text/javascript" src="./js/sigma.min.js"></script>
  <script type="text/javascript" src="./js/jquery.min.js"></script>
  <script type="text/javascript">
  $(function() {
    sigma.classes.graph.addMethod(
      'getNeighborhood',
      function(centerId) {
        var k1,
            k2,
            k3,
            node,
            center,
            // Those two local indexes are here just to avoid duplicates:
            localNodesIndex = {},
            localEdgesIndex = {},
            // And here is the resulted graph, empty at the moment:
            graph = {
              nodes: {},
              edges: {}
            };

        // Check that the exists:
        if (!this.nodes(centerId))
          return graph;

        // Add center. It has to be cloned to add it the "center" attribute
        // without altering the current graph:
        node = this.nodes(centerId);
        center = {};
        center.center = true;
        for (k1 in node)
          center[k1] = node[k1];

        localNodesIndex[centerId] = true;
        graph.nodes[centerId] = 1;

        // Add neighbors and edges between the center and the neighbors:
        for (k1 in this.allNeighborsIndex[centerId]) {
          if (!localNodesIndex[k1]) {
            localNodesIndex[k1] = true;
            graph.nodes[k1] = 1;
          }

          for (k2 in this.allNeighborsIndex[centerId][k1])
            if (!localEdgesIndex[k2]) {
              localEdgesIndex[k2] = true;
              graph.edges[k2] = 1;
            }
        }

        // Add edges connecting two neighbors:
        for (k1 in localNodesIndex)
          if (k1 !== centerId)
            for (k2 in localNodesIndex)
              if (
                k2 !== centerId &&
                k1 !== k2 &&
                this.allNeighborsIndex[k1][k2]
              )
                for (k3 in this.allNeighborsIndex[k1][k2])
                  if (!localEdgesIndex[k3]) {
                    localEdgesIndex[k3] = true;
                    graph.edges[k3] = 1;
                  }

        // Finally, let's return the final graph:
        return graph;
      }
    );

    $.ajax({
      url: './data/mlp-bipartite-graph.json',
      dataType: 'json',
      success: function(data) {
        // Clean data:
        data.nodes.forEach(function(node) {
          node.trueColor = node.color;
        });
        data.edges.forEach(function(edge) {
          edge.weight = edge.size;
          delete edge.color;
        });

        var s = new sigma({
          renderers: [{
            container: document.getElementById('graph'),
            type: 'canvas'
          }],
          settings: {
            font: '"Alegreya Sans", sans-serif',
            defaultEdgeColor: 'rgba(0, 0, 0, 0.1)',
            edgeColor: 'default',
            labelThreshold: 6.7
          }
        });

        s.bind('overNode', function(e) {
          var node = e.data.node.id,
              graph = s.graph.getNeighborhood(node);

          s.graph.edges().forEach(function(edge) {
            if (graph.edges[edge.id])
              edge.color = '#888';
            else
              edge.color = 'rgba(0, 0, 0, 0.1)';
          });

          s.graph.nodes().forEach(function(node) {
            if (graph.nodes[node.id])
              node.color = node.trueColor;
            else
              node.color = '#ccc';
          });
          s.refresh();
        }).bind('outNode', function(e) {
          s.graph.nodes().forEach(function(node) {
            node.color = node.trueColor;
          });
          s.graph.edges().forEach(function(edge) {
            delete edge.color;
          });
          s.refresh();
        });

        setTimeout(function() {
          s.graph.read(data);
          s.refresh();
        }, 100);
      }
    });
  });
  </script>
</body>
</html>
